# two_hopf:
#   equation:
#     x: '2*pi*y*w + b*u*x +(e*x-x*(x*x+y*y))*100.0'
#     y: '-2*pi*x*w + b*v*y + (e*y-y*(x*x+y*y))*100.0'
#     u: '2*pi*v*f + (e*u-u*(u*u+v*v))*100.0'
#     v: '-2*pi*u*f + (e*v-v*(u*u+v*v))*100.0'
#   parameters:
#     w: 200.0
#     f: 10.5
#     e: 10.0
#     a: 10.0
#     b: 0.0
#   output:
#     x: 
#       gain: 0.4
#     y:
#       gain: 0.4

# vdp:
#   reset:  
#   equation:
#     x: '2*pi*y*w + d'
#     y: '-2*pi*x*w+ u*(1-x*x)*y'
#   parameters:
#     u: 1000.0
#     w: 200.0
#     d: 0
#   output:
#     x: 
#       gain: 0.4
#     y:
#       gain: 0.4

# lorenz: &lorenz
#   equation:
#     x: 'sigma*(y-x)*tau' 
#     y: '(x*(rho-z)-y)*tau'
#     z: '(x*y-beta*z)*tau'
#   parameters:
#     sigma: 11
#     rho: 26
#     beta: 2.6666
#     tau: 200.0
#   init:
#     x: 1.0
#     y: 1.0
#     z: 1.0
#   output:
#     y: 
#       gain: 0.6
#       pan: 0

# lorenz2: 
#   <<: *lorenz
#   parameters:
#     sigma: 11
#     rho: 28
#     beta: 2.6666
#     tau: 100.0
#   output:
#     y: 
#       gain: 0.4
#       pan: 0


# hopfmod:
#   equation:
#     x: ' 2*pi*y*w + (a*sin(2*pi*f*t) + e*x-x*(x*x+y*y))*s'
#     y: '-2*pi*x*w + (e*y-y*(x*x+y*y))*s'
#   parameters:
#     w: 300
#     e: 20.0
#     f: 5.0
#     a: 20.0
#     s: 1000.0
#   output:
#     x: 
#       gain: 0.5
#     y:
#       gain: 0.5

# hr:
#   functions:
#     phi: 
#       args: [x,a,b]
#       formula: -a*x*x*x + b*x*x
#     psi: 
#       args: [x,c,d]
#       formula: c - d*x*x
#   equation:
#     x: (y + phi(x,a,b) - z + i)*tau
#     y: (psi(x,c,d) - y)*tau
#     z: (r*(s*(x-x_r)-z))*tau
#   parameters:
#     a: 1
#     b: 3 + lroenz.y*0
#     c: 1
#     d: 5
#     r: 0.005
#     s: 5
#     xr: -1.6
#     i: -2
#     tau: 1000
#   output:
#     x: {gain: 0.3, pan: -1}
#     y: {gain: 0.3, pan: 1}

logistic:
  discrete: true
  equation:
    x: r*x*(1-x)
  init:
    x: 0.1
  parameters:
    r: 3.9
    hz: 500

hopf:
  equation:
    x: ' 2*pi*y*w + (e*x-x*(x*x+y*y)+i)*s'
    y: '-2*pi*x*w + (e*y-y*(x*x+y*y))*s'
  parameters:
    w: 100 + logistic.x*100
    e: -10 + logistic.x*10
    s: 100.0
    i: 0.0
  output:
    x: {gain: 1.0, pan: -1}
    y: {gain: 1.0, pan: 1}


# henon:
#   map:
#     x: '1-a*x*x+y'
#     y: 'b*x'
#   init:
#     x: 0
#     y: 1
#   parameters:
#     a: 1.4
#     b: 0.3



# hopf2:
#   equation:
#     x: ' 2*pi*y*w + (e*x-x*(x*x+y*y))*s'
#     y: '-2*pi*x*w + (e*y-y*(x*x+y*y))*s'
#   parameters:
#     w: 310 #+ lorenz.x*100
#     e: 10.0
#     s: 100.0
#   output:
#     x: 
#       gain: 0.2
#     y:
#       gain: 0.2

# map:
#   discrete: true
#   equation:
#     x: y
#     y: -x
#   init:
#     x: 1
#     y: -1
#   parameters:
#     hz: 4

